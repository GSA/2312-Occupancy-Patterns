---
title: "Data preparation for team category analysis"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: united
    highlight: tango
    code_folding: hide
params:
  author: "Ben Jaques-Leslie"
  project_number: 2312
  project_name: "Occupancy Patterns"
  google_drive_home: "G:/Shared drives/MSG Projects/1.0 Real Estate Solutions (LQ1)/2312 Work Patterns"
  data_folder_1: "prepared-data"
  data_file_1: "check_in_panel_2023-04-12.rdata"
  unique_identifier_1: !r c("date","person_id")
  date_cohort_month: "2022-03-01"
  observation_window_length_months: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
tictoc::tic()
if(!("arsenal" %in% installed.packages()[,"Package"]))
{
  install.packages("arsenal")
}
if(!("oesrrr" %in% installed.packages()[,"Package"]))
{
  devtools::install_github(repo = "GSA/oesrrr")
}
library(oesrrr)
library(tidyverse)
library(janitor)
library(skimr)
library(DataExplorer)
library(readr)
library(arsenal)
library(Hmisc)
library(readxl)
library(flextable)
library(ggthemes)
```

```{r cohort dates}
date_cohort_month_start <- ymd(params$date_cohort_month)
date_cohort_month_end <- ceiling_date(date_cohort_month_start,unit = "month") %>% rollbackward()
date_observation_window_month_start <- date_cohort_month_start %m+% months(params$observation_window_length_months)
date_observation_window_month_end <- ceiling_date(date_observation_window_month_start,unit = "month") %>% rollbackward()
```

# Data preparation {.tabset .tabset-pills}

**Project number**: `r params$project_number`

**Project name**: `r params$project_name`

**Author**: `r params$author`

**Data folder 1**: `r params$data_folder_1`

**Data file 1**: `r params$data_file_1`

**Unique identifier for data file 1**: `r params$unique_identifier_1`

**Cohort start month**: `r nice_month_year(date_cohort_month_start)`

**Observation window**: `r nice_month_year(date_cohort_month_start)` to `r nice_month_year(date_observation_window_month_end)` (`r params$observation_window_length_months` months)

## Load data {.tabset .tabset-pills}

Load `r params$data_file_1` from `r params$data_folder_1` data folder.

```{r}
load(file = file.path(params$google_drive_home,"03. Data Collection",params$data_folder_1,params$data_file_1))
```

Review.

```{r}
check_in_panel %>% 
  skim()
```

Updated data type for check-in status.

```{r}
check_in_panel <- 
  check_in_panel %>% 
  mutate(
    daily_status_imputed = factor(daily_status_imputed),
    daily_status_imputed =
      fct_recode(daily_status_imputed,
                 permanent_departure = "This employee is no longer with the agency (retired, resigned, or other form of permanent departure)")
  )
```

Create days of the week for dates.

```{r}
check_in_panel <- 
  check_in_panel %>% 
  mutate(date_day_of_week = wday(date, label = TRUE))
```

## Creating cohort {.tabset .tabset-pills}

Collect `person_id` and `supervisor_e_mail_address` of employees that worked in `r nice_month_year(date_cohort_month_start)`. If a team member had multiple supervisors, select the first one. 

```{r}
cohort_ids <- 
  check_in_panel %>% 
  filter(date >= date_cohort_month_start & date <= date_cohort_month_end) %>% 
  arrange(person_id,date) %>% 
  group_by(person_id) %>% 
  summarise(
    supervisor_e_mail_address = first(supervisor_e_mail_address)
  ) %>% 
  ungroup()
```

Review.

```{r}
cohort_ids %>% 
  skim()
```

Join with full panel.

```{r}
cohort_panel <- 
  cohort_ids %>% 
  inner_join(check_in_panel) %>% 
  filter(date >= date_cohort_month_start & date <= date_observation_window_month_end)
```

Review.

```{r}
cohort_panel %>% 
  skim()
```

Check: These have the same number of unique `person_id`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(person_id)) %>% 
  pull() ==
  cohort_panel %>% 
  summarise(n_distinct(person_id)) %>% 
  pull()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  cohort_panel %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Create dataframe of all initial characteristics.

```{r}
cohort_first <- 
  cohort_panel %>% 
  arrange(person_id,date) %>% 
  group_by(person_id) %>% 
  summarise(
    across(
      .cols = everything(),
      .fns = first
    )
  ) %>% 
  ungroup()
```

Review.

```{r}
cohort_first %>% 
  skim()
```

Check: These have the same number of unique `person_id`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(person_id)) %>% 
  pull() ==
  cohort_first %>% 
  summarise(n_distinct(person_id)) %>% 
  pull()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  cohort_panel %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Set up `prep_building`.

```{r}
prep_building <- 
  cohort_ids %>% 
  select(supervisor_e_mail_address) %>% 
  distinct()
```

## Creating aggregated variables {.tabset .tabset-pills}

### Team, whole period variables

For following variables are aggregated for the whole period for the whole team:

-   Proportion of team members working days onsite

-   Proportion of team members working days remote

-   Number of team members working days

First, calculating the number of days in the observation window.

```{r}
observation_window_days <- 
  cohort_panel %>% 
  summarise(observation_window_days = n_distinct(date)) %>% 
  ungroup() %>% 
  pull()

observation_window_days
```

Now calculating the number of days per team by `daily_status_imputed`. Proportions are caluculated for onsite and telework only. The calculations are made in two ways in two ways. First as a proportion of team working days:

$$
\frac{\sum_{m=1}^{x}DailyStatusDays_m}{\sum_{m=1}^{x}WorkingDays_m}
$$

where

$$
WorkingDays_m = OnsiteDays_m + TeleworkDays_m
$$

$OnsiteDays_m$ is the number of onsite days for team member $m$ and $TeleworkDays_m$ is the number of telework days for team member $m$. $x$ is number of members on team.

Second as a proportion of days in the observations window:

$$
\frac{\sum_{m=1}^{x}DailyStatusDays_m}{x\times ObservationWindowDays}
$$

Now we calculate the values for the data.

First count the number of distinct days per `supervisor_e_mail_address`, `person_id`, and `daily_status_imputed`, then filter to daily status: *Reporting to Job Site* or *Teleworking*.

```{r}
prep_a <-
  cohort_panel %>%
  group_by(supervisor_e_mail_address,person_id,daily_status_imputed,.drop = FALSE) %>% 
  summarise(working_days = n_distinct(date)) %>% 
  ungroup() %>% 
  filter(
    daily_status_imputed == "Reporting to Job Site" |
      daily_status_imputed == "Teleworking"
  )
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Second, sum the number days by `supervisor_e_mail_address` from dataframe `prep_a`.

```{r}
prep_b <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(
    working_days = sum(working_days)
  ) %>% 
  ungroup()
```


Review data.

```{r}
prep_b %>% 
  skim()
```

Third, sum the number days by `supervisor_e_mail_address` and `daily_status_imputed` from dataframe `prep_a` and reshape the data wide so that statuses are in columns, `daily_status_*`.

```{r}
prep_c <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address,daily_status_imputed) %>% 
  summarise(
    working_days = sum(working_days)
  ) %>% 
  ungroup() %>% 
  pivot_wider(values_from = working_days, names_from = daily_status_imputed) %>% 
  clean_names() %>% 
  rename_with(~glue::glue("daily_status_{.}"), -supervisor_e_mail_address)
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Fourth, count the number of unique team members per supervisor.

```{r}
prep_d <-
  cohort_panel %>%
  group_by(supervisor_e_mail_address) %>% 
  summarise(
    team_members = n_distinct(person_id)
  ) %>% 
  ungroup()
```

Review data.

```{r}
prep_d %>% 
  skim()
```

Join working days, working days per status, and team members into one dataframe by `supervisor_e_mail_address`.

```{r}
prep_e <- 
  prep_b %>% 
  full_join(prep_c) %>% 
  full_join(prep_d)
```

Review data.

```{r}
prep_e %>% 
  skim()
```

Calucate `observation_window_days`, `daily_status_reporting_to_job_site_working_prop`, `daily_status_teleworking_working_prop`, `daily_status_reporting_to_job_site_observation_prop`, and `daily_status_teleworking_observation_prop`, then replace missing values with zero.

```{r}
prep_xx <- 
  prep_e %>% 
  mutate(
    observation_window_days = team_members*observation_window_days,
    daily_status_reporting_to_job_site_working_prop = daily_status_reporting_to_job_site/working_days,
    daily_status_teleworking_working_prop = daily_status_teleworking/working_days,
    daily_status_reporting_to_job_site_observation_prop = daily_status_reporting_to_job_site/observation_window_days,
    daily_status_teleworking_observation_prop = daily_status_teleworking/observation_window_days
  ) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  )
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Team, day of week variables

For following variables are aggregated for the whole period by day of the week for the whole team:

-   Proportion of team members working days remote by the day of the
    week

#### Proportion of days remote by day of the week

First, calculating the number of days in the observation window.

```{r}
observation_window_days_day_of_week <- 
  cohort_panel %>% 
  group_by(date_day_of_week) %>% 
  summarise(observation_window_days = n_distinct(date)) %>% 
  ungroup()

observation_window_days_day_of_week
```


First count the number of distinct days per `supervisor_e_mail_address`, `date_day_of_week`, `person_id`, and `daily_status_imputed`, then filter to daily status: *Reporting to Job Site* or *Teleworking*.

```{r}
prep_a <-
  cohort_panel %>%
  group_by(supervisor_e_mail_address,person_id,daily_status_imputed,date_day_of_week,.drop = FALSE) %>% 
  summarise(working_days = n_distinct(date)) %>% 
  ungroup() %>% 
  filter(
    daily_status_imputed == "Reporting to Job Site" |
      daily_status_imputed == "Teleworking"
  )
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Second, sum the number days by `supervisor_e_mail_address` and `date_day_of_week` from dataframe `prep_a`.

```{r}
prep_b <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address,date_day_of_week) %>% 
  summarise(
    working_days = sum(working_days)
  ) %>% 
  ungroup()
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Third, sum the number days by `supervisor_e_mail_address`, `date_day_of_week` and `daily_status_imputed` from dataframe `prep_a` and reshape the data wide so that statuses are in columns, `daily_status_*`.

```{r}
prep_c <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address,daily_status_imputed,date_day_of_week) %>% 
  summarise(
    working_days = sum(working_days)
  ) %>% 
  ungroup() %>% 
  pivot_wider(values_from = working_days, names_from = daily_status_imputed) %>% 
  clean_names() %>% 
  rename_with(~glue::glue("daily_status_{.}"), c(-supervisor_e_mail_address,-date_day_of_week))
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Fourth, count the number of unique team members per `supervisor_e_mail_address` and `date_day_of_week`.

```{r}
prep_d <-
  cohort_panel %>%
  group_by(supervisor_e_mail_address,date_day_of_week) %>% 
  summarise(
    team_members = n_distinct(person_id)
  ) %>% 
  ungroup()
```

Review data.

```{r}
prep_d %>% 
  skim()
```

Join working days, working days per status, and team members into one dataframe by `supervisor_e_mail_address`.

```{r}
prep_e <- 
  prep_b %>% 
  full_join(prep_c) %>% 
  full_join(prep_d) %>% 
  left_join(observation_window_days_day_of_week)
```

Review data.

```{r}
prep_e %>% 
  skim()
```

Review data by `date_day_of_week`.

```{r}
prep_e %>% 
  group_by(date_day_of_week) %>% 
  skim()
```

Filter out *Sat* and *Sun* as there are no working days. 

```{r}
prep_f <- 
  prep_e %>% 
  filter(date_day_of_week != "Sat" &
           date_day_of_week != "Sun")
```

Review data.

```{r}
prep_f %>% 
  skim()
```

Calucate `observation_window_days`, `daily_status_reporting_to_job_site_working_prop`, `daily_status_teleworking_working_prop`, `daily_status_reporting_to_job_site_observation_prop`, and `daily_status_teleworking_observation_prop`, then replace missing values with zero.

```{r}
prep_g <- 
  prep_f %>% 
  mutate(
    observation_window_days = team_members*observation_window_days,
    daily_status_reporting_to_job_site_working_prop = daily_status_reporting_to_job_site/working_days,
    daily_status_teleworking_working_prop = daily_status_teleworking/working_days,
    daily_status_reporting_to_job_site_observation_prop = daily_status_reporting_to_job_site/observation_window_days,
    daily_status_teleworking_observation_prop = daily_status_teleworking/observation_window_days
  ) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  )
```

Review data.

```{r}
prep_g %>% 
  skim()
```

Now collect only the results for telework.

```{r}
prep_xx <- 
  prep_g %>% 
  select(supervisor_e_mail_address,
         date_day_of_week,daily_status_teleworking_working_prop,daily_status_teleworking_observation_prop) %>% 
  pivot_longer(cols = starts_with("daily_status")) %>% 
  mutate(date_day_of_week = str_to_lower(date_day_of_week)) %>% 
  unite("name",date_day_of_week,name) %>% 
  pivot_wider(values_from = value, names_from = name) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  )
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Modal size of team over observation window

Calculate number of team members per day by supervisor email.

```{r}
prep_a <- 
  cohort_panel %>% 
  group_by(date,supervisor_e_mail_address) %>% 
  summarise(team_size = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Calculate the mode team size for each `supervisor_e_mail_address`.

```{r}
prep_xx <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(team_size_mode = getmode(team_size)) %>% 
  ungroup()
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Proportion of team members exiting team

Calculate the number of days and last day of team members by `supervisor_e_mail_address`, and `person_id`.

```{r}
prep_a <- 
  cohort_panel %>% 
  group_by(supervisor_e_mail_address,person_id) %>% 
  summarise(days = n_distinct(date),
            last_day = max(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Identify team members that exit by limiting the list above to those who had few than the maximum number of days and whose last day was before the maxium day in the dataframe, then count the number per `supervisor_e_mail_address`.

```{r}
prep_b <- 
  prep_a %>% 
  filter(days < max(days)) %>% 
  filter(last_day < max(last_day)) %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(employee_exits = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Attach to `prep_building` selecting `supervisor_e_mail_address` and `team_members` from that dataframe to calucalate the proportio of the team exiting.

```{r}
prep_c <- 
  prep_building %>% 
  select(supervisor_e_mail_address, team_members) %>% 
  distinct() %>% 
  left_join(prep_b) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  ) %>% 
  mutate(
    employee_exits_prop = employee_exits/team_members
  )
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Remove `team_members`.

```{r}
prep_xx <- 
  prep_c %>% 
  select(-team_members)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Proportion of observation window the team existed

Calculate the number of days and last day of team members by `supervisor_e_mail_address`.

```{r}
prep_a <- 
  cohort_panel %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(team_days = n_distinct(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Calculate the number of days and last day of team members by `supervisor_e_mail_address`.

```{r}
prep_xx <- 
  prep_a %>% 
  mutate(
    team_days_prop = team_days/observation_window_days
  )
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Proportion of working days at least two team members co-located

Identify employees who report to the site and collect `person_id`, `dates`, `location`, and `supervisor_e_mail_address`.

```{r}
prep_a <-
  cohort_panel %>%
  filter(daily_status_imputed == "Reporting to Job Site") %>%
  select(person_id, date, location, supervisor_e_mail_address) %>%
  distinct()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Self left join on `dates`, `location`, and `supervisor_e_mail_address` and filter to rows where the `person_id`s do not match.

```{r}
prep_b <- 
  prep_a %>% 
  left_join(prep_a,
            by = c("date", "location", "supervisor_e_mail_address"),
            suffix = c("","_joined")) %>%
  filter(person_id != person_id_joined)
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Count dates where co-location occurs by `supervisor_e_mail_address`.

```{r}
prep_c <- 
  prep_b %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(days_colocated_1 = n_distinct(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Full join `working_days` from `prep_building`, calculate proportion of co-located days with at least one team member by `working_days` and `observation_window_days`, replace nulls with 0, and remove `working_days`.

```{r}
prep_xx <- 
  prep_c %>% 
  full_join(prep_building %>% 
              select(supervisor_e_mail_address,working_days)) %>% 
  mutate(days_colocated_1_working_prop = days_colocated_1/working_days,
         days_colocated_1_observation_prop = days_colocated_1/observation_window_days) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  ) %>% 
  select(-working_days)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Proportion of working days supervisor is co-located with at least one team member

Identify employees who report to the site and collect `person_id`, `dates`, `location`, `employee_e_mail_address`, and `supervisor_e_mail_address`.

```{r}
prep_a <-
  cohort_panel %>%
  filter(daily_status_imputed == "Reporting to Job Site") %>%
  select(person_id, date, location, employee_e_mail_address, supervisor_e_mail_address) %>%
  distinct()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Self inner join on `dates`, `location`, and `supervisor_e_mail_address` equal to `employee_e_mail_address` in the right table, and filter to rows where the `person_id`s do not match.

```{r}
prep_b <- 
  prep_a %>% 
  inner_join(prep_a,
            by = c("date", "location", "supervisor_e_mail_address" = "employee_e_mail_address"),
            suffix = c("","_joined")) 
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Count dates where co-location with supervisor occurs by `supervisor_e_mail_address`.

```{r}
prep_c <- 
  prep_b %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(days_colocated_supervisor = n_distinct(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Full join `working_days` and `observation_window_days` from `prep_building`, calculate proportion of co-located days with at least one team member by `working_days` and `observation_window_days`, replace nulls with 0, and remove `working_days` and `observation_window_days`.

```{r}
prep_xx <- 
  prep_c %>% 
  full_join(prep_building %>% 
              select(supervisor_e_mail_address,working_days,observation_window_days)) %>% 
  mutate(days_colocated_supervisor_working_prop = days_colocated_supervisor/working_days,
         days_colocated_supervisor_observation_prop = days_colocated_supervisor/observation_window_days) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  ) %>% 
  select(-working_days,-observation_window_days)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```
### Proportion of working days entire team is co-located

Identify employees who report to the site and collect `person_id`, `dates`, `location`, and `supervisor_e_mail_address`.

```{r}
prep_a <-
  cohort_panel %>%
  filter(daily_status_imputed == "Reporting to Job Site") %>%
  select(person_id, date, location, supervisor_e_mail_address) %>%
  distinct()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Count number of team members co-located by `supervisor_e_mail_address`, `location`, and `date` by counting unique `person_id`.

```{r}
prep_b <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address,location, date) %>% 
  summarise(colocated_team_members = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Calculate number of team members per day by supervisor email.

```{r}
prep_c <- 
  cohort_panel %>% 
  group_by(date,supervisor_e_mail_address) %>% 
  summarise(team_size = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Left join co-located team members and teams size, but `date` and `supervisor_e_mail_address`, then filter to when co-located team members is the same size as the team

```{r}
prep_d <- 
  prep_b %>% 
  left_join(prep_c) %>% 
  filter(colocated_team_members == team_size)
```

Review data.

```{r}
prep_d %>% 
  skim()
```


Count dates where co-location with whole team occurs by `supervisor_e_mail_address`.

```{r}
prep_e <- 
  prep_d %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(days_colocated_team = n_distinct(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_e %>% 
  skim()
```

Full join `working_days` and `observation_window_days` from `prep_building`, calculate proportion of co-located days with team member by `working_days` and `observation_window_days`, replace nulls with 0, and remove `working_days` and `observation_window_days`.

```{r}
prep_xx <- 
  prep_e %>% 
  full_join(prep_building %>% 
              select(supervisor_e_mail_address,working_days,observation_window_days)) %>% 
  mutate(days_colocated_team_working_prop = days_colocated_team/working_days,
         days_colocated_team_observation_prop = days_colocated_team/observation_window_days) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  ) %>% 
  select(-working_days,-observation_window_days)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Proportion of working days entire team is remote

Identify employees who are teleworking and collect `person_id`, `dates`, and `supervisor_e_mail_address`.

```{r}
prep_a <-
  cohort_panel %>%
  filter(daily_status_imputed == "Teleworking") %>%
  select(person_id, date, supervisor_e_mail_address) %>%
  distinct()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Count number of team members co-located by `supervisor_e_mail_address`, and `date` by counting unique `person_id`.

```{r}
prep_b <- 
  prep_a %>% 
  group_by(supervisor_e_mail_address,date) %>% 
  summarise(telework_team_members = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Calculate number of team members per day by supervisor email.

```{r}
prep_c <- 
  cohort_panel %>% 
  group_by(date,supervisor_e_mail_address) %>% 
  summarise(team_size = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Left join teleworking team members and teams size, by `date` and `supervisor_e_mail_address`, then filter to when teleworking team members is the same size as the team.

```{r}
prep_d <- 
  prep_b %>% 
  left_join(prep_c) %>% 
  filter(telework_team_members == team_size)
```

Review data.

```{r}
prep_d %>% 
  skim()
```


Count dates where co-location with whole team occurs by `supervisor_e_mail_address`.

```{r}
prep_e <- 
  prep_d %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(days_telework_team = n_distinct(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_e %>% 
  skim()
```

Full join `team_days` and `observation_window_days` from `prep_building`, calculate proportion of co-located days with team member by `team_days` and `observation_window_days`, replace nulls with 0, and remove `team_days` and `observation_window_days`.

```{r}
prep_xx <- 
  prep_e %>% 
  full_join(prep_building %>% 
              select(supervisor_e_mail_address,team_days)) %>% 
  mutate(days_telework_team_working_prop =  days_telework_team/team_days,
         days_telework_team_observation_prop = days_telework_team/observation_window_days) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  ) %>% 
  select(-team_days)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

## Define rule-based groups {.tabset .tabset-pills}

The analysis plan defines ten rule-based groups for analysis:

1.  **All remote** - All team members are 100% remote
2.  **Routine teleworker** - All team members who have
    `position_category_description`'s *Onsite Flexible* or *Offsite* and
    work at least two two days per pay period onsite.
3.  **Onsite Flexible** - All team members are *Onsite Flexible* as
    defined by `position_category_description` in the roster data
4.  **Offsite** - All team members are *Offsite* as defined by team
    members `position_category_description` in the roster data
5.  **Onsite Required** - All team members are *Onsite Required* as
    defined by `position_category_description` in the roster data
6.  **Mixed position categories** - Team members are different position
    categories as as defined by `position_category_description` in the
    roster data
7.  **Primarily remote** - Teams that work remotely above the 95th
    percentile <!-- could be 75th -->
8.  **Mostly remote** - Teams that work remotely between the median and
    the 95th percentile <!-- could be 75th -->
9.  **Mostly onsite** - Teams that work remotely between 5th percentile
    and the median <!-- could be 25th -->
10. **Primarily onsite** - Teams that work remotely below the 5th
    percentile <!-- could be 75th -->

Below the variables for the groups are created. 

### All remote

Define workers with 100% of their time as **all remote**.

```{r}
prep_xx <- 
  prep_building %>% 
  mutate(
    rule_based_all_remote = case_when(
      daily_status_teleworking_working_prop == 1 ~ 1,
                                      TRUE ~ 0)
  ) %>% 
  select(supervisor_e_mail_address,starts_with("rule_based_"))
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Primarily, mostly onsite and remote

First, calculate the quantiles for probabilities 0.50 and 0.95.

```{r}
prep_a <- 
  prep_building %>% 
  summarise(
    across(
      .cols = c(daily_status_reporting_to_job_site_working_prop,daily_status_teleworking_working_prop,
                daily_status_reporting_to_job_site_observation_prop,daily_status_teleworking_observation_prop),
      .fns = list(q_95 = ~quantile(.,probs = .95),
                  q_50 = ~quantile(.,probs = .50))
    )
  )
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Use the quantiles above to create new variables for `primarily_` and `mostly_` working remote or onsite. 

```{r}
prep_xx <-
  prep_building %>%
  select(
    supervisor_e_mail_address,
    daily_status_reporting_to_job_site_working_prop,
    daily_status_teleworking_working_prop,
    daily_status_reporting_to_job_site_observation_prop,
    daily_status_teleworking_observation_prop
  ) %>%
  mutate(
    rule_based_primarily_reporting_to_job_site_working =
      case_when(
        daily_status_reporting_to_job_site_working_prop >= prep_a$daily_status_reporting_to_job_site_working_prop_q_95 ~ 1,
        TRUE ~ 0
      ),
    rule_based_primarily_teleworking_working =
      case_when(
        daily_status_teleworking_working_prop >= prep_a$daily_status_teleworking_working_prop_q_95 ~ 1,
        TRUE ~ 0
      ),
    rule_based_primarily_reporting_to_job_site_observation =
      case_when(
        daily_status_reporting_to_job_site_observation_prop >= prep_a$daily_status_reporting_to_job_site_observation_prop_q_95 ~ 1,
        TRUE ~ 0
      ),
    rule_based_primarily_teleworking_observation =
      case_when(
        daily_status_teleworking_observation_prop >= prep_a$daily_status_teleworking_observation_prop_q_95 ~ 1,
        TRUE ~ 0
      ),
    rule_based_mostly_reporting_to_job_site_working =
      case_when(
        daily_status_reporting_to_job_site_working_prop >= prep_a$daily_status_reporting_to_job_site_working_prop_q_50 ~ 1,
        TRUE ~ 0
      ),
    rule_based_mostly_teleworking_working =
      case_when(
        daily_status_teleworking_working_prop >= prep_a$daily_status_teleworking_working_prop_q_50 ~ 1,
        TRUE ~ 0
      ),
    rule_based_mostly_reporting_to_job_site_observation =
      case_when(
        daily_status_reporting_to_job_site_observation_prop >= prep_a$daily_status_reporting_to_job_site_observation_prop_q_50 ~ 1,
        TRUE ~ 0
      ),
    rule_based_mostly_teleworking_observation =
      case_when(
        daily_status_teleworking_observation_prop >= prep_a$daily_status_teleworking_observation_prop_q_50 ~ 1,
        TRUE ~ 0
      ),
  ) %>%
  select(supervisor_e_mail_address, starts_with("rule_based_"))
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Position description categories

```{r, eval=FALSE}
prep_b <- 
  cohort_panel %>% 
  group_by(person_id) %>% 
  summarise(
    across(
      .cols = position_category_description,
      .fns = getmode
    )
  )
  
prep_c <- 
  cohort_first %>% 
  select(person_id,position_category_description)

prep_c %>% 
  inner_join(prep_b, by = "person_id") %>% 
  filter(position_category_description.x != position_category_description.y)
```

Identify the `position_category_description` at the beginning of the observation window and count number of team members per category by `supervisor_e_mail_address`.  

```{r}
prep_a <- 
  cohort_panel %>% 
  group_by(supervisor_e_mail_address,position_category_description) %>% 
  summarise(team_members = n_distinct(person_id)) %>% 
  ungroup() %>% 
  pivot_wider(values_from = team_members, names_from = position_category_description,
              names_prefix = "rule_based_position_category_") %>% 
  clean_names()
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Inner join with `prep_building` selecting `supervisor_e_mail_address`, and `team_members`.

```{r}
prep_b <- 
  prep_building %>% 
  select(supervisor_e_mail_address,team_members) %>% 
  inner_join(prep_a)
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Create indicators for when the number of team members equals the number of members in a specific category.

```{r}
prep_c <- 
  prep_b %>% 
  mutate(
    across(
      .cols = starts_with("rule_based_position_category_"),
      .fns = ~case_when(. == team_members ~ 1,
                        TRUE ~ 0)
    )
  )
```

Review data.

```{r}
prep_c %>% 
  skim()
```

Left join to `prep_building` selecting only `supervisor_e_mail_address` and remove `team_members`.

```{r}
prep_xx <-
  prep_building %>% 
  select(supervisor_e_mail_address) %>% 
  left_join(prep_c) %>% 
  select(-team_members)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```


Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Teleworker

First define pay periods based on this: https://www.gsa.gov/cdnstatic/GSA_Payroll_Calendar_2022_Revised.pdf. File is also saved in `r file.path(params$google_drive_home,"04. Analysis","documents")`.

```{r}
prep_a <- 
  tibble(
  date = seq.Date(from = ymd("2022-01-01"),
         to = ymd("2022-12-31"),
         by = "2 weeks")
) %>% 
  rownames_to_column(var = "period_number") 
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Second, create a dataframe of all the days of the year.

```{r}
prep_b <- 
  tibble(
  date = seq.Date(from = ymd("2022-01-01"),
         to = ymd("2022-12-31"),
         by = "days")
)
```

Review data.

```{r}
prep_b %>% 
  skim()
```

Third, left join the pay periods dataframe (`prep_a`) to the days of the year (`prep_b`), then fill the null `period_number` values with the entry above.

```{r}
prep_c <- 
  prep_b %>% 
  left_join(prep_a) %>% 
  fill(period_number, .direction = "down")
```
Review data.

```{r}
prep_c %>% 
  skim()
```

Fourth, take the cohort panel (`cohort_panel`) select `person_id`, `date`, and `daily_status_imputed` and left join to calendar dataframe with filled `period_number` (`prep_c`) on `date`. 

```{r}
prep_d <- 
  cohort_panel %>% 
  select(person_id,date, daily_status_imputed) %>% 
  left_join(prep_c)
```

Review data.

```{r}
prep_d %>% 
  skim()
```

Fifth, count the number of unique days by `person_id`, `daily_status_imputed`, and `period_number`.

```{r}
prep_e <- 
      prep_d %>% 
  group_by(person_id,daily_status_imputed,period_number) %>% 
  summarise(days = n_distinct(date)) %>% 
  ungroup()
```

Review data.

```{r}
prep_e %>% 
  skim()
```

Sixth, filter to only see observations where `daily_status_imputed` is "Reporting to Job Site" and create `telework_onsite_minimum` to be 1 when `days` is greater than or equal to 2, that is employees have at least two days in the office in that pay period. Then, calculate the mean `telework_onsite_minimum` (`telework_onsite_minimum_mean`) per employee. Those where this is 1 are in the office at least two days per pay period for the whole observation window. Lastly, create `telework_onsite_minimum` to be 1 when `telework_onsite_minimum_mean` is 1.

```{r}
prep_f <- 
  prep_e %>% 
  filter(daily_status_imputed == "Reporting to Job Site") %>% 
  mutate(
    telework_onsite_minimum = case_when(days >= 2 ~ 1,
                                        TRUE ~ 0)
  ) %>% 
  group_by(person_id) %>% 
  summarise(
    telework_onsite_minimum_mean = mean(telework_onsite_minimum)
  ) %>% 
  ungroup() %>% 
  mutate(
    telework_onsite_minimum = case_when(telework_onsite_minimum_mean == 1 ~ 1,
                                        TRUE ~ 0)
  )
```

Review data.

```{r}
prep_f %>% 
  skim()
```

Seventh, select `person_id`, and `position_category_description` from the beginning of the observation window (`cohort_first`) and left join the above (`prep_f`). Then, create `rule_based_telework_onsite_minimum` when `telework_onsite_minimum` is 1 and `position_category_description` is *Onsite Flexible* or *Offsite*.

```{r}
prep_g <- 
  cohort_first %>% 
  select(person_id,position_category_description) %>% 
  left_join(prep_f) %>% 
  mutate(
    rule_based_telework_onsite_minimum = 
      case_when(telework_onsite_minimum == 1 & position_category_description == "Onsite Flexible" ~ 1,
                telework_onsite_minimum == 1 & position_category_description == "Offsite" ~ 1,
                TRUE ~ 0)
  ) %>%
  select(person_id, starts_with("rule_based_"))
```

Review data.

```{r}
prep_g %>% 
  skim()
```

Left join to `cohort_ids`.

```{r}
prep_h <- 
  cohort_ids %>% 
  left_join(prep_g)
```

Review data.

```{r}
prep_h %>% 
  skim()
```

Filter to team members who met the onsite minimum and count by `supervisor_e_mail_address`.

```{r}
prep_i <- 
  prep_h %>% 
  filter(rule_based_telework_onsite_minimum == 1) %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(rule_based_telework_onsite_minimum = n_distinct(person_id)) %>% 
  ungroup()
```

Review data.

```{r}
prep_i %>% 
  skim()
```

From `cohort_panel` count number of team members with **Onsite flexible** or **Offsite** `position_category_description` by `supervisor_e_mail_address`.

```{r}
prep_j <- 
  cohort_panel %>% 
  filter(position_category_description == "Onsite Flexible" |
           position_category_description == "Offsite") %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(team_members_telework = n_distinct(person_id)) %>% 
  ungroup() 
```

Review data.

```{r}
prep_j %>% 
  skim()
```

Full join and identify rows where all teleworking team members meet the minimum. 

```{r}
prep_k <- 
  prep_i %>% 
  full_join(prep_j) %>% 
  mutate(
    rule_based_telework_onsite_minimum = case_when(rule_based_telework_onsite_minimum == team_members_telework ~ 1,
                    TRUE ~ 0)
  ) %>% 
  select(-team_members_telework)
```

Review data.

```{r}
prep_k %>% 
  skim()
```


Left join to `prep_building` selecting only `supervisor_e_mail_address` and remove `team_members`.

```{r}
prep_xx <-
  prep_building %>% 
  select(supervisor_e_mail_address) %>% 
  left_join(prep_k) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  )
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

### Mixed categories

From `cohort_panel` count team members by `position_category_description` and `supervisor_e_mail_address`, then filter to only `position_category_description`s that are **Onsite Flexible**, **Offsite**, or **Onsite Required**, then count `position_category_description` by `supervisor_e_mail_address`, then create `rule_based_mixed_position_category` identifying teams with more than one category, and last drop the temporary variable. 

```{r}
prep_a <-
  cohort_panel %>% 
  group_by(supervisor_e_mail_address,position_category_description) %>% 
  summarise(team_members = n_distinct(person_id)) %>% 
  ungroup() %>% 
  filter(position_category_description == "Onsite Flexible" |
           position_category_description == "Offsite" |
           position_category_description == "Onsite Required") %>% 
  group_by(supervisor_e_mail_address) %>% 
  summarise(temp_var = n_distinct(position_category_description)) %>% 
  ungroup() %>% 
   mutate(
     rule_based_mixed_position_category = case_when(temp_var > 1 ~ 1,
                                                    TRUE ~ 0)
     ) %>% 
  select(-temp_var)
```

Review data.

```{r}
prep_a %>% 
  skim()
```

Left join to `prep_building` selecting only `supervisor_e_mail_address`.

```{r}
prep_xx <-
  prep_building %>% 
  select(supervisor_e_mail_address) %>% 
  left_join(prep_a) %>% 
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~replace_na(.,0)
    )
  )
```

Review data.

```{r}
prep_xx %>% 
  skim()
```

Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

## Attach characteristics

Collect initial characteristics for supervisors for `check_in_panel` by joining `supervisor_e_mail_address` in `prep_building` to `employee_e_mail_address` and selecting for the first rows for each `supervisor_e_mail_address` by `date`.

```{r}
prep_a <-
  prep_building %>%
  select(supervisor_e_mail_address) %>%
  distinct() %>%
  inner_join(
    check_in_panel,
    by = c("supervisor_e_mail_address" = "employee_e_mail_address"),
    suffix = c("", "_of_supervisor")
  ) %>%
  arrange(supervisor_e_mail_address, date) %>%
  group_by(supervisor_e_mail_address) %>%
  summarise(across(.cols = everything(),
                   .fns = first)) %>%
  ungroup()
```

Review data

```{r}
prep_a %>% 
  skim()
```

Create initial summary data of the team aggregating `cohort_first` by `supervisor_e_mail_address` and collecting the mode and distinct count for most variables. 

```{r}
prep_b <-
  cohort_first %>%
  group_by(supervisor_e_mail_address) %>%
  summarise(across(
    .cols = c(
      -where(is.Date),-employee_e_mail_address,-position_category_code,-employee_name,-supervisor_display_name,-date_day_of_week,-position_number,-business_line_2_letter_department_id
    ),
    .fns = list(dist = n_distinct, mode = getmode),
    .names = "{.col}_{.fn}"
  )) %>%
  select(-person_id_mode) %>%
  ungroup()
```

Review data

```{r}
prep_b %>% 
  skim()
```

Collect the minimum and maximum GS levels for the team by `supervisor_e_mail_address` from `cohort_first`.

```{r}
prep_c <-
  cohort_first %>%
  group_by(supervisor_e_mail_address) %>%
  summarise(across(
    .cols = c(grade),
    .fns = list(min = min, max = max),
    .names = "{.col}_{.fn}"
  )) %>%
  ungroup()
```


Review data

```{r}
prep_c %>% 
  skim()
```

Create `prep_xx` by left joining the above to `supervisor_e_mail_address` in `prep_building`.

```{r}
prep_xx <-
  cohort_ids %>%
  select(supervisor_e_mail_address) %>%
  distinct() %>%
  left_join(prep_a) %>%
  left_join(prep_b) %>%
  left_join(prep_c)
```

Review data.

```{r}
prep_xx %>% 
  skim()
```


Check: These have the same number of unique `supervisor_e_mail_address`.

```{r}
cohort_ids %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull() ==
  prep_xx %>% 
  summarise(n_distinct(supervisor_e_mail_address)) %>% 
  pull()
```

Join to `prep_building`.

```{r}
prep_building <- 
  prep_building %>% 
  left_join(prep_xx)
```

## Addressing blanks, nulls, and other values

Created a dataframe of variable metadata.

```{r}
column_meta_data <- 
  prep_building %>% 
  contents()

column_meta_data <- 
  column_meta_data$contents %>% 
  as.data.frame()

column_meta_data <-
  column_meta_data %>% 
  rownames_to_column(var = "variable")

column_meta_data <- 
  column_meta_data %>% 
  mutate(
    nulls_by_variable = case_when(NAs > 0 ~ TRUE,
                                  NAs == 0 ~ FALSE)
  )

column_meta_data
```

Counting top 10 values for all character or factor columns to identify other common values.

```{r}
values_count <- 
  prep_building %>% 
  select(where(is.character) | where(is.factor)) %>% 
  names()

values_count %>% 
  map(~count(prep_building,!!sym(.)) %>% 
  arrange(desc(n)) %>%
  slice_head(n = 10))

```

No obvious values.

Function that checks whether there are blanks for different variables

```{r}
blank_check <- function(in_data,in_variable_name)
{
  check_01 <- 
  in_data %>% 
    filter(!!sym(in_variable_name) == "") %>% 
  distinct()

out <- nrow(check_01) > 0 

return(out)
}
```

Checking blanks for each variable in the dataframe.

```{r}
blanks_by_variable <- 
  column_meta_data %>% 
  pull(variable) %>% 
  map_lgl(~blank_check(in_data = prep_building,.))

blanks_by_variable
```

Add this to the `column_meta_data` dataframe.

```{r}
column_meta_data <- 
  column_meta_data %>% 
  add_column(
    blanks_by_variable = blanks_by_variable
  )

column_meta_data
```

Create dataframe of only variables that have blanks.

```{r}
problem_variables <- 
  column_meta_data %>% 
  filter(blanks_by_variable | nulls_by_variable)

problem_variables
```

All of these are null from supervisors that didn't show up in the panel data. 

## Creating final dataframe

```{r}
prep_team <- prep_building
```

```{r}
rm(prep_building)
```

## Save data {.tabset .tabset-pills}

```{r}
save(prep_team, file = file.path(params$google_drive_home,"03. Data Collection","prepared-data",
          glue::glue("prep_team_{Sys.Date()}.rdata")))
```

Remove all data elements.

```{r}
rm(list = ls())
gc()
```

## Extraction time {.tabset .tabset-pills}

```{r}
tictoc::toc()
```
